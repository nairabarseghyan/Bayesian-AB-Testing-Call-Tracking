{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>bayesian_ab_testing</code> documentation","text":""},{"location":"#how-to-install","title":"How to install","text":"<p>Note: python version 3.11 or above required</p> <pre><code>pip install bayesian_ab_testing\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>bayesian_ab_testing\n    api\n    data_preparation\n    models\n</code></pre>"},{"location":"api/","title":"<code>bayesian_ab_testing.api</code>","text":"<p>This module contains an example API ready to go.</p> <code>get_arm</code> <p>handles GET at <code>/arm</code> </p> <p>Gets arm information, or multiple if id = -1</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>id of arm. Defaults to -1.</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>arm info</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.get(\"/arm\")\nasync def get_arm(id: int = -1) -&gt; dict:\n    \"\"\"Gets arm information, or multiple if id = -1\n\n    Args:\n        id (int, optional): id of arm. Defaults to -1.\n\n    Returns:\n        dict: arm info\n    \"\"\"    \n    with SqlHandler(\"DimArm\") as dim_arm:\n        if id &lt; 0:\n            res = dim_arm.from_sql_to_pandas().to_dict()\n\n            return {k:{id:v[id]} if id &lt; len(v) and id &gt;= 0 else v for k, v in res.items()} if id is not None else res\n        else:\n            res = dim_arm.select_one(id)\n\n    return res\n</code></pre> <p></p> <code>add_arm</code> <p>handles POST at <code>/arm</code> </p> <p>Adds an arm</p> <p>Parameters:</p> Name Type Description Default <code>customer_id</code> <code>int</code> <p>identifier</p> required <code>type</code> <code>str</code> <p>type</p> required <code>reward</code> <code>float</code> <p>Amount of reward per trigger</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Arm as a dict</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.post(\"/arm\")\nasync def add_arm(customer_id: int, type: str, reward: float) -&gt; dict:\n    \"\"\"Adds an arm\n\n    Args:\n        customer_id (int): identifier\n        type (str): type\n        reward (float): Amount of reward per trigger\n\n    Returns:\n        dict: Arm as a dict\n    \"\"\"    \n    id = SqlHandler(\"DimArm\").get_next_id()\n    ThompsonArm(id, cnxn, type=type, customer_id=customer_id, reward=reward)\n\n    return {\"arm_id\": id, \"type\": type, \"reward\": reward, \"active\": 1}\n</code></pre> <p></p> <code>mod_arm</code> <p>handles PUT at <code>/arm/type</code> </p> <p>Modifies the type of the arm</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>arm identifier</p> required <code>type</code> <code>Union[str, None]</code> <p>type</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"ok\" if ok</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.put(\"/arm/type\")\nasync def mod_arm(id: int, type: Union[str, None]) -&gt; str:\n    \"\"\"Modifies the type of the arm\n\n    Args:\n        id (int): arm identifier\n        type (Union[str, None]): type\n\n    Returns:\n        str: \"ok\" if ok\n    \"\"\"    \n    try:\n        ThompsonArm(id).change_type(type)\n    except ValueError as e:\n        return \"ValueError: \" + str(e)\n    return \"ok\"\n</code></pre> <p></p> <code>toggle_arm</code> <p>handles PUT at <code>/arm</code> </p> <p>Turns an arm on/off</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>arm id</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ok or error message</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.put(\"/arm\")\nasync def toggle_arm(id: int) -&gt; str:\n    \"\"\"Turns an arm on/off\n\n    Args:\n        id (int): arm id\n\n    Returns:\n        str: ok or error message\n    \"\"\"\n\n    try:\n        ThompsonArm(id, cnxn).toggle_active()\n    except ValueError as e:\n        logging.error(e)\n        return \"ValueError: \" + str(e)\n\n    return \"ok\"\n</code></pre> <p></p> <code>sample_arm</code> <p>handles GET at <code>/sample</code> </p> <p>Samples from all arms and choses the best one</p> <p>Parameters:</p> Name Type Description Default <code>customer_id</code> <code>int</code> <p>Customer id</p> required <code>information</code> <code>Union[str, None]</code> <p>Additional client data</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>a serve object as a dict</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.get(\"/sample\")\nasync def sample_arm(customer_id: int, information: Union[str, None]) -&gt; dict:\n    \"\"\"Samples from all arms and choses the best one\n\n    Args:\n        customer_id (int): Customer id\n        information (Union[str, None]): Additional client data\n\n    Returns:\n        dict: a serve object as a dict\n    \"\"\"    \n    algo = ThompsonAlgo(cnxn, customer_id)\n    serve = algo.get_best_arm(information)\n\n    return serve\n</code></pre> <p></p> <code>log_result</code> <p>handles PUT at <code>/sample</code> </p> <p>Logs a trigger</p> <p>Parameters:</p> Name Type Description Default <code>customer_id</code> <code>int</code> <p>Customer identifier</p> required <code>arm_id</code> <code>int</code> <p>Arm identifier</p> required <code>serve_id</code> <code>int</code> <p>Serve identifier</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"ok\" of ok</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.put(\"/sample\")\nasync def log_result(customer_id, arm_id, serve_id) -&gt; str:\n    \"\"\"Logs a trigger\n\n    Args:\n        customer_id (int): Customer identifier\n        arm_id (int): Arm identifier\n        serve_id (int): Serve identifier\n\n    Returns:\n        str: \"ok\" of ok\n    \"\"\"    \n    algo = ThompsonAlgo(cnxn, customer_id)\n    [arm for arm in algo.arms if arm.id == int(arm_id)][0].log_trigger(serve_id)\n    return \"ok\"\n</code></pre> <p></p> <code>stats</code> <p>handles GET at <code>/stats</code> </p> <p>Summary statistics and state of an arm</p> <p>Parameters:</p> Name Type Description Default <code>arm_id</code> <code>int</code> <p>arm identifier</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dict with aggregated values and state</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.get(\"/stats\")\nasync def stats(arm_id: int) -&gt; dict:\n    \"\"\"Summary statistics and state of an arm\n\n    Args:\n        arm_id (int): arm identifier\n\n    Returns:\n        dict: Dict with aggregated values and state\n    \"\"\"    \n    agr = SqlHandler(\"AggregateResult\")\n    res = agr.select_one(arm_id)\n    return res\n</code></pre> <p></p> <code>add_client</code> <p>handles POST at <code>/client</code> </p> <p>Adds a client to the db</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name</p> required <code>location</code> <code>str</code> <p>location</p> required <code>contact</code> <code>str</code> <p>contact info</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>customer as a dict</p> Source code in <code>bayesian_ab_testing\\api\\api.py</code> <pre><code>@app.post(\"/client\")\nasync def add_client(name:str, location: str, contact: str) -&gt; dict:\n    \"\"\"Adds a client to the db\n\n    Args:\n        name (str): Name\n        location (str): location\n        contact (str): contact info\n\n    Returns:\n        dict: customer as a dict\n    \"\"\"    \n    cust = SqlHandler(\"DimCustomer\")\n    id = cust.get_next_id()\n    cust_dict = dict(customer_id=id, name=name, location=location, contact=contact)\n    cust.insert_one(**cust_dict)\n\n    return cust_dict\n</code></pre> <p></p>"},{"location":"data_preparation/","title":"<code>bayesian_ab_testing.data_preparation</code>Object-relational mapperData generationSQL Handler","text":"<p>This module contains fake data generators that one can use to test the package.</p> <code>create_ORM</code> <p>Creates the sql tables by mapping objects to it</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to sqlite db</p> required Source code in <code>bayesian_ab_testing\\data_preparation\\schema.py</code> <pre><code>def create_ORM(path):\n    \"\"\"Creates the sql tables by mapping objects to it\n\n    Args:\n        path (str): path to sqlite db\n    \"\"\"    \n\n    engine = create_engine(f'sqlite:///{path}')\n\n    Base = declarative_base()\n\n    class DimDate(Base):\n        __tablename__ = \"DimDate\"\n\n        date_id = Column(Integer, primary_key=True)\n        date = Column(DateTime)\n        day = Column(Integer)\n        month = Column(Integer)\n        quarter = Column(Integer)\n        year = Column(Integer)\n\n\n    class DimArm(Base):\n        __tablename__ = \"DimArm\"\n\n        arm_id = Column(Integer, primary_key=True)\n        type = Column(String)\n        reward = Column(Float)\n        active = Column(Boolean)\n\n\n    class DimCustomer(Base):\n        __tablename__ = \"DimCustomer\"\n\n        customer_id = Column(Integer, primary_key=True)\n        name = Column(String)\n        location = Column(String)\n        contact = Column(String)\n\n\n    class Serve(Base):\n        __tablename__ = \"Serve\"\n\n        serve_id = Column(Integer, primary_key=True)\n        date_id = Column(Integer, ForeignKey('DimDate.date_id'))\n        customer_id = Column(Integer, ForeignKey('DimCustomer.customer_id'))\n        arm_id = Column(Integer, ForeignKey('DimArm.arm_id'))\n        information = Column(String)\n        result = Column(Boolean, nullable = True)\n\n\n    class AggregateResult(Base):\n        __tablename__ = \"AggregateResult\"\n\n        arm_id = Column(Integer, primary_key=True)\n        customer_id = Column(Integer)\n        n_triggered = Column(Integer)\n        n_served = Column(Integer)\n        a = Column(Float)\n        b = Column(Float)\n        average_reward = Column(Float)\n\n\n\n\n    Base.metadata.create_all(engine)\n    del Base\n    del engine\n</code></pre> <p></p> <code>generate_arm</code> <p>Generates an arm</p> <p>Parameters:</p> Name Type Description Default <code>arm_id</code> <code>int</code> <p>arm_id</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>arm</p> Source code in <code>bayesian_ab_testing\\data_preparation\\data_generator.py</code> <pre><code>def generate_arm(arm_id) -&gt; dict:\n    \"\"\"Generates an arm\n\n    Args:\n        arm_id (int): arm_id\n\n    Returns:\n        dict: arm\n    \"\"\"    \n\n    return {\n        \"arm_id\": arm_id,\n        \"type\": fake.word(),\n        \"reward\": np.random.randint(1, 15),\n        \"active\": np.random.uniform() &gt; 0.85\n    }\n</code></pre> <p></p> <code>generate_customer</code> <p>Generates a customer with random info</p> <p>Parameters:</p> Name Type Description Default <code>customer_id</code> <code>int</code> <p>customer_id</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>customer</p> Source code in <code>bayesian_ab_testing\\data_preparation\\data_generator.py</code> <pre><code>def generate_customer(customer_id) -&gt; dict:\n    \"\"\"Generates a customer with random info\n\n    Args:\n        customer_id (int): customer_id\n\n    Returns:\n        dict: customer\n    \"\"\"    \n\n    return {\n        \"customer_id\": customer_id,\n        \"name\": fake.name(),\n        \"location\": fake.street_address(),\n        \"contact\": fake.phone_number()\n    }\n</code></pre> <p></p> <code>generate_date</code> <p>Generates a random date in 2023</p> <p>Parameters:</p> Name Type Description Default <code>date_id</code> <code>int</code> <p>date_id</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>date</p> Source code in <code>bayesian_ab_testing\\data_preparation\\data_generator.py</code> <pre><code>def generate_date(date_id) -&gt; dict:\n    \"\"\"Generates a random date in 2023\n\n    Args:\n        date_id (int): date_id\n\n    Returns:\n        dict: date \n    \"\"\"    \n\n    # Generate a random date between a specific date range\n    start_date = datetime(2023, 1, 1)\n    end_date = datetime(2023, 12, 31)\n    random_date = fake.date_time_between_dates(start_date, end_date)\n\n    # Extract year, quarter, and month from the random date\n    year = random_date.year\n    quarter = (random_date.month - 1) // 3 + 1\n    month = random_date.strftime('%m')\n    day = random_date.strftime('%d')\n\n    return {\n        \"date_id\": date_id,\n        \"date\": random_date.strftime(\"%Y-%m-%d\"),\n        \"day\": day,\n        \"month\": month,\n        \"quarter\": quarter,\n        \"year\": year\n    }\n</code></pre> <p></p> <code>generate_serve</code> <p>Generates a serve with random info</p> <p>Parameters:</p> Name Type Description Default <code>serve_id</code> <code>int</code> <p>serve_id</p> required <code>date_id</code> <code>int</code> <p>date_id</p> required <code>customer_id</code> <code>int</code> <p>customer_id</p> required <code>arm_id</code> <code>int</code> <p>arm_id</p> required <code>p</code> <code>float</code> <p>probability of success</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>serve</p> Source code in <code>bayesian_ab_testing\\data_preparation\\data_generator.py</code> <pre><code>def generate_serve(serve_id, date_id, customer_id, arm_id, p) -&gt; dict:\n    \"\"\"Generates a serve with random info\n\n    Args:\n        serve_id (int): serve_id\n        date_id (int): date_id\n        customer_id (int): customer_id\n        arm_id (int): arm_id\n        p (float): probability of success\n\n    Returns:\n        dict: serve\n    \"\"\"    \n\n    return {\n        \"serve_id\": serve_id,\n        \"date_id\": date_id,\n        \"customer_id\": customer_id,\n        \"arm_id\": arm_id,\n        \"information\": json.dumps(fake.profile()),\n        \"result\": np.random.uniform() &gt;= p\n    }\n</code></pre> <p></p> <code>SqlHandler</code> <p>             Bases: <code>ISQL_Etiquette</code></p> <p>Handles all interactions with the database</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>class SqlHandler(ISQL_Etiquette):\n    \"\"\"Handles all interactions with the database\"\"\"\n\n    def __init__(self, table_name: str) -&gt; None:\n        \"\"\"Initializes the sql handler of the table `table_name`\n\n        Args:\n            table_name (str): Which table to tether the handler to\n        \"\"\"        \n        super().__init__()\n\n        self.cnxn = sqlite3.connect(db_path)\n        self.table_name = table_name\n\n        cur = self.exec(f'SELECT l.name FROM pragma_table_info(\"{table_name}\") as l WHERE l.pk = 1;')\n        self.pk = list(cur)[0][0]\n\n\n    def __enter__(self):\n        \"\"\"Interfaces python `with` syntax\"\"\"\n        return self\n\n\n    def __exit__(self, *args, **kwargs):\n        \"\"\"Exits the python `with` scope\"\"\"\n\n        self.close_cnxn()\n\n\n    def close_cnxn(self)-&gt;None:\n        \"\"\"Close the connection gracefully\"\"\"\n\n        logger.info('commiting the changes')\n        self.cnxn.commit()\n        logger.debug('closing connection')\n        self.cnxn.close()\n        logger.info('the connection has been closed')\n\n\n    def insert_one(self, **kwargs) -&gt; None:\n        \"\"\"Insert a single row into the table\"\"\"\n\n        query = f\"INSERT INTO {self.table_name} ({', '.join([k for k in kwargs.keys()])}) VALUES ({', '.join(['?'] * len(kwargs))});\"\n        logging.debug(query, [v for v in kwargs.values()])\n\n        cur = self.exec(query, [v for v in kwargs.values()])\n        logging.info(\"insert_one: \" + str(list(cur)))\n\n\n    def get_table_columns(self) -&gt; list:\n        \"\"\"Gets a list of the column names that belong to the table\"\"\"\n\n        cur = self.exec(f\"PRAGMA table_info({self.table_name});\")\n        columns = cur.fetchall()\n\n        column_names = [col[1] for col in columns]\n        logger.info(f'the list of columns: {column_names}')\n\n        return column_names\n\n\n    def truncate_table(self) -&gt; None:\n        \"\"\"Deletes all rows of the table\"\"\"\n\n        query=f\"delete from {self.table_name} where 1=1;\"\n        logging.info(f'the {self.table_name} is being truncated')\n        self.exec(query)\n\n\n    def drop_table(self):\n        \"\"\"Drops the table from the database\"\"\"\n\n        query = f\"DROP TABLE IF EXISTS {self.table_name};\"\n        logging.info(query)\n\n        self.exec(query)\n        logging.info(f\"table '{self.table_name}' deleted.\")\n\n\n    def insert_many(self, df: pd.DataFrame):\n        \"\"\"Insert many values at once into the table\n\n        Args:\n            df (pd.DataFrame): data to insert\n        \"\"\"     \n\n        df = df.replace(np.nan, None)\n        df.rename(columns = lambda x: x.lower(), inplace=True)\n\n        columns = list(df.columns)\n        logger.info(f'BEFORE the column intersection: {columns}')\n\n        sql_column_names = [i.lower() for i in self.get_table_columns()]\n        columns = list(set(columns) &amp; set(sql_column_names))\n        logger.info(f'AFTER the column intersection: {columns}')\n\n        assert len(df.columns) == len(sql_column_names), \"Mismatch in columns between the dataframe and the sql table. \\ndf.columns: \" + \\\n            \", \".join(df.columns) + \"\\nsql columns: \" + \", \".join(sql_column_names)\n\n        ncolumns = list(len(columns) * '?')\n        data_to_insert = df.loc[:, columns]\n        values = [tuple(i) for i in data_to_insert.values]\n\n        logger.info(f'the shape of the table which is going to be imported {data_to_insert.shape}')\n\n        if len(columns)&gt;1:\n            cols, params =', '.join(columns), ', '.join(ncolumns)\n        else:\n            cols, params = columns, ncolumns\n\n        logger.info(f'insert structure: colnames: {cols} params: {params}')\n        logger.info(values[0])\n        query=f\"\"\"INSERT INTO {self.table_name} ({cols}) VALUES ({params});\"\"\"\n\n        logger.info(f'QUERY: {query}')\n\n        cur = self.exec_many(query, values)\n\n        try:\n            for i in cur.messages:\n                logger.info(i)\n        except:\n            pass\n\n        logger.warning('the data is loaded')\n\n\n    def from_sql_to_pandas(self, chunksize:int=64) -&gt; pd.DataFrame:\n        \"\"\"Converts the table into a pandas dataframe and returns it, \n        reads the table in `chnksize`-sized chunks\n\n        Args:\n            chunksize (int, optional): Number of rows per sql request. Defaults to 64.\n\n        Returns:\n            pd.DataFrame: data\n        \"\"\"        \n\n        offset=0\n        dfs=[]\n\n        while True:\n            query=f\"\"\"\n            SELECT * FROM {self.table_name}\n                LIMIT {chunksize}  \n                OFFSET {offset}\n            \"\"\"\n            data = pd.read_sql_query(query, self.cnxn)\n            self.cnxn.commit()\n\n            logger.info(f'the shape of the chunk: {data.shape}')\n\n            dfs.append(data)\n            offset += chunksize\n\n            if len(dfs[-1]) &lt; chunksize:\n                logger.info('loading the data from SQL is finished')\n                logger.debug('connection is closed')\n                break\n\n        df = pd.concat(dfs)\n\n        return df\n\n\n    def update_table(self, set_values: dict, condition: str):\n        \"\"\"Updates some the values of some fields of some rows (based on the condition)\n\n        Args:\n            set_values (dict): which columns to assign which values\n            condition (str): condition upon which to update\n        \"\"\"\n\n        if not set_values:\n            logger.warning('No values to update. Provide set_values.')\n            return\n\n        set_clause = ', '.join(f\"{col} = ?\" for col in set_values.keys())\n        values = list(set_values.values())\n\n        query = f\"\"\"\n        UPDATE {self.table_name}\n        SET {set_clause}\n        WHERE {condition};\n        \"\"\"\n\n        cur = self.exec(query, values if hasattr(values, \"__iter__\") else list(values))\n\n        logger.info(f\"Rows updated: {cur.rowcount}\")\n\n\n    def update_one(self, id: int, **kwargs: dict):\n        \"\"\"Updates a single row in the table\n\n        Args:\n            id (int): row to update\n        \"\"\"\n\n        cond = self.pk + \" = \" + str(id)\n        self.update_table(kwargs, cond)\n\n\n    def select_one(self, id: int, cols: list = []) -&gt; dict:\n        \"\"\"Selects only one row and returns it as a python dictionary\n\n        Args:\n            id (int): id of row\n            cols (list, optional): Which columns to select. Selects all columns if the list is empty. Defaults to [].\n\n        Returns:\n            dict: row\n        \"\"\"   \n\n        cond = self.pk + \" = ?\"\n        query = f\"select {'*' if len(cols) == 0 else ', '.join(cols)} from {self.table_name} where {cond}\"\n        cur = self.exec(query, (id, ))\n\n        return {k:v for k, v in zip(self.get_table_columns() if len(cols) == 0 else cols, list(cur)[0])}\n\n\n    def get_next_id(self):\n        \"\"\"Conveniently gets the increment of the previous id (used for creating a new entry)\"\"\"\n\n        query = f\"select (max({self.pk}) + 1) from {self.table_name};\"\n        cur = list(self.exec(query))\n        cur = cur[0]\n\n        return 0 if cur is None else cur[0] if cur[0] is not None else 0\n</code></pre> <p></p>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.__enter__","title":"<code>__enter__()</code>","text":"<p>Interfaces python <code>with</code> syntax</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def __enter__(self):\n    \"\"\"Interfaces python `with` syntax\"\"\"\n    return self\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.__exit__","title":"<code>__exit__(*args, **kwargs)</code>","text":"<p>Exits the python <code>with</code> scope</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def __exit__(self, *args, **kwargs):\n    \"\"\"Exits the python `with` scope\"\"\"\n\n    self.close_cnxn()\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.__init__","title":"<code>__init__(table_name)</code>","text":"<p>Initializes the sql handler of the table <code>table_name</code></p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Which table to tether the handler to</p> required Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def __init__(self, table_name: str) -&gt; None:\n    \"\"\"Initializes the sql handler of the table `table_name`\n\n    Args:\n        table_name (str): Which table to tether the handler to\n    \"\"\"        \n    super().__init__()\n\n    self.cnxn = sqlite3.connect(db_path)\n    self.table_name = table_name\n\n    cur = self.exec(f'SELECT l.name FROM pragma_table_info(\"{table_name}\") as l WHERE l.pk = 1;')\n    self.pk = list(cur)[0][0]\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.close_cnxn","title":"<code>close_cnxn()</code>","text":"<p>Close the connection gracefully</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def close_cnxn(self)-&gt;None:\n    \"\"\"Close the connection gracefully\"\"\"\n\n    logger.info('commiting the changes')\n    self.cnxn.commit()\n    logger.debug('closing connection')\n    self.cnxn.close()\n    logger.info('the connection has been closed')\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.drop_table","title":"<code>drop_table()</code>","text":"<p>Drops the table from the database</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def drop_table(self):\n    \"\"\"Drops the table from the database\"\"\"\n\n    query = f\"DROP TABLE IF EXISTS {self.table_name};\"\n    logging.info(query)\n\n    self.exec(query)\n    logging.info(f\"table '{self.table_name}' deleted.\")\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.from_sql_to_pandas","title":"<code>from_sql_to_pandas(chunksize=64)</code>","text":"<p>Converts the table into a pandas dataframe and returns it,  reads the table in <code>chnksize</code>-sized chunks</p> <p>Parameters:</p> Name Type Description Default <code>chunksize</code> <code>int</code> <p>Number of rows per sql request. Defaults to 64.</p> <code>64</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: data</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def from_sql_to_pandas(self, chunksize:int=64) -&gt; pd.DataFrame:\n    \"\"\"Converts the table into a pandas dataframe and returns it, \n    reads the table in `chnksize`-sized chunks\n\n    Args:\n        chunksize (int, optional): Number of rows per sql request. Defaults to 64.\n\n    Returns:\n        pd.DataFrame: data\n    \"\"\"        \n\n    offset=0\n    dfs=[]\n\n    while True:\n        query=f\"\"\"\n        SELECT * FROM {self.table_name}\n            LIMIT {chunksize}  \n            OFFSET {offset}\n        \"\"\"\n        data = pd.read_sql_query(query, self.cnxn)\n        self.cnxn.commit()\n\n        logger.info(f'the shape of the chunk: {data.shape}')\n\n        dfs.append(data)\n        offset += chunksize\n\n        if len(dfs[-1]) &lt; chunksize:\n            logger.info('loading the data from SQL is finished')\n            logger.debug('connection is closed')\n            break\n\n    df = pd.concat(dfs)\n\n    return df\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.get_next_id","title":"<code>get_next_id()</code>","text":"<p>Conveniently gets the increment of the previous id (used for creating a new entry)</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def get_next_id(self):\n    \"\"\"Conveniently gets the increment of the previous id (used for creating a new entry)\"\"\"\n\n    query = f\"select (max({self.pk}) + 1) from {self.table_name};\"\n    cur = list(self.exec(query))\n    cur = cur[0]\n\n    return 0 if cur is None else cur[0] if cur[0] is not None else 0\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.get_table_columns","title":"<code>get_table_columns()</code>","text":"<p>Gets a list of the column names that belong to the table</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def get_table_columns(self) -&gt; list:\n    \"\"\"Gets a list of the column names that belong to the table\"\"\"\n\n    cur = self.exec(f\"PRAGMA table_info({self.table_name});\")\n    columns = cur.fetchall()\n\n    column_names = [col[1] for col in columns]\n    logger.info(f'the list of columns: {column_names}')\n\n    return column_names\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.insert_many","title":"<code>insert_many(df)</code>","text":"<p>Insert many values at once into the table</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>data to insert</p> required Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def insert_many(self, df: pd.DataFrame):\n    \"\"\"Insert many values at once into the table\n\n    Args:\n        df (pd.DataFrame): data to insert\n    \"\"\"     \n\n    df = df.replace(np.nan, None)\n    df.rename(columns = lambda x: x.lower(), inplace=True)\n\n    columns = list(df.columns)\n    logger.info(f'BEFORE the column intersection: {columns}')\n\n    sql_column_names = [i.lower() for i in self.get_table_columns()]\n    columns = list(set(columns) &amp; set(sql_column_names))\n    logger.info(f'AFTER the column intersection: {columns}')\n\n    assert len(df.columns) == len(sql_column_names), \"Mismatch in columns between the dataframe and the sql table. \\ndf.columns: \" + \\\n        \", \".join(df.columns) + \"\\nsql columns: \" + \", \".join(sql_column_names)\n\n    ncolumns = list(len(columns) * '?')\n    data_to_insert = df.loc[:, columns]\n    values = [tuple(i) for i in data_to_insert.values]\n\n    logger.info(f'the shape of the table which is going to be imported {data_to_insert.shape}')\n\n    if len(columns)&gt;1:\n        cols, params =', '.join(columns), ', '.join(ncolumns)\n    else:\n        cols, params = columns, ncolumns\n\n    logger.info(f'insert structure: colnames: {cols} params: {params}')\n    logger.info(values[0])\n    query=f\"\"\"INSERT INTO {self.table_name} ({cols}) VALUES ({params});\"\"\"\n\n    logger.info(f'QUERY: {query}')\n\n    cur = self.exec_many(query, values)\n\n    try:\n        for i in cur.messages:\n            logger.info(i)\n    except:\n        pass\n\n    logger.warning('the data is loaded')\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.insert_one","title":"<code>insert_one(**kwargs)</code>","text":"<p>Insert a single row into the table</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def insert_one(self, **kwargs) -&gt; None:\n    \"\"\"Insert a single row into the table\"\"\"\n\n    query = f\"INSERT INTO {self.table_name} ({', '.join([k for k in kwargs.keys()])}) VALUES ({', '.join(['?'] * len(kwargs))});\"\n    logging.debug(query, [v for v in kwargs.values()])\n\n    cur = self.exec(query, [v for v in kwargs.values()])\n    logging.info(\"insert_one: \" + str(list(cur)))\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.select_one","title":"<code>select_one(id, cols=[])</code>","text":"<p>Selects only one row and returns it as a python dictionary</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>id of row</p> required <code>cols</code> <code>list</code> <p>Which columns to select. Selects all columns if the list is empty. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>row</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def select_one(self, id: int, cols: list = []) -&gt; dict:\n    \"\"\"Selects only one row and returns it as a python dictionary\n\n    Args:\n        id (int): id of row\n        cols (list, optional): Which columns to select. Selects all columns if the list is empty. Defaults to [].\n\n    Returns:\n        dict: row\n    \"\"\"   \n\n    cond = self.pk + \" = ?\"\n    query = f\"select {'*' if len(cols) == 0 else ', '.join(cols)} from {self.table_name} where {cond}\"\n    cur = self.exec(query, (id, ))\n\n    return {k:v for k, v in zip(self.get_table_columns() if len(cols) == 0 else cols, list(cur)[0])}\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.truncate_table","title":"<code>truncate_table()</code>","text":"<p>Deletes all rows of the table</p> Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def truncate_table(self) -&gt; None:\n    \"\"\"Deletes all rows of the table\"\"\"\n\n    query=f\"delete from {self.table_name} where 1=1;\"\n    logging.info(f'the {self.table_name} is being truncated')\n    self.exec(query)\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.update_one","title":"<code>update_one(id, **kwargs)</code>","text":"<p>Updates a single row in the table</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>row to update</p> required Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def update_one(self, id: int, **kwargs: dict):\n    \"\"\"Updates a single row in the table\n\n    Args:\n        id (int): row to update\n    \"\"\"\n\n    cond = self.pk + \" = \" + str(id)\n    self.update_table(kwargs, cond)\n</code></pre>"},{"location":"data_preparation/#bayesian_ab_testing.data_preparation.SqlHandler.update_table","title":"<code>update_table(set_values, condition)</code>","text":"<p>Updates some the values of some fields of some rows (based on the condition)</p> <p>Parameters:</p> Name Type Description Default <code>set_values</code> <code>dict</code> <p>which columns to assign which values</p> required <code>condition</code> <code>str</code> <p>condition upon which to update</p> required Source code in <code>bayesian_ab_testing\\data_preparation\\sql_interactions.py</code> <pre><code>def update_table(self, set_values: dict, condition: str):\n    \"\"\"Updates some the values of some fields of some rows (based on the condition)\n\n    Args:\n        set_values (dict): which columns to assign which values\n        condition (str): condition upon which to update\n    \"\"\"\n\n    if not set_values:\n        logger.warning('No values to update. Provide set_values.')\n        return\n\n    set_clause = ', '.join(f\"{col} = ?\" for col in set_values.keys())\n    values = list(set_values.values())\n\n    query = f\"\"\"\n    UPDATE {self.table_name}\n    SET {set_clause}\n    WHERE {condition};\n    \"\"\"\n\n    cur = self.exec(query, values if hasattr(values, \"__iter__\") else list(values))\n\n    logger.info(f\"Rows updated: {cur.rowcount}\")\n</code></pre>"},{"location":"models/","title":"<code>bayesian_ab_testing.models</code>Thompson sampling with bernoulli reward","text":"<code>TS_Bernoulli.ThompsonAlgo</code> <p>             Bases: <code>ISQL_Etiquette</code></p> <p>The sampling algorithm used for live A/B testing</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>class ThompsonAlgo(ISQL_Etiquette):\n    \"\"\"The sampling algorithm used for live A/B testing\"\"\"\n\n    def __init__(self, cnxn: sqlite3.Connection, customer_id: int):\n        \"\"\"Constructor that initializes the thompson algorithm\n\n        Args:\n            cnxn (sqlite3.Connection): Connection to db\n            customer_id (int): customer_id\n\n        Raises:\n            ValueError: The customer has no active arms\n        \"\"\"        \n\n        self.cnxn = cnxn\n        self.customer_id = customer_id\n\n        arms = list(self.exec(\n            \"select arm_id, type, reward, active from DimArm where arm_id in (select arm_id from AggregateResult where customer_id = ?)\", \n            (customer_id,)\n        ))\n\n        if len([i for i in arms if i[-1]]) == 0:\n            logging.error((em := \"The customer has no active arms\"))\n            raise ValueError(em)\n\n        self.arms = [ThompsonArm(arm_id, cnxn, type=type_, reward=reward, active=active, customer_id=customer_id) for arm_id, type_, reward, active in arms]\n\n\n    def get_best_arm(self, information: str = None) -&gt; dict:\n        \"\"\"Samples the best arm\n\n        Args:\n            information (str, optional): Information provided by the customer to be stored without structure. Defaults to None.\n\n        Returns:\n            dict: serve \n        \"\"\"        \n        j = np.argmax([arm.pull() for arm in self.arms])\n        best_arm = self.arms[j]\n        serve = best_arm.log_sampled(information)\n\n        return serve\n</code></pre> <p></p> <code>TS_Bernoulli.ThompsonArm</code> <p>             Bases: <code>ISQL_Etiquette</code></p> <p>An implementation of the Thompson Sampling algorithm arm.</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>class ThompsonArm(ISQL_Etiquette):\n    \"\"\"\n    An implementation of the Thompson Sampling algorithm arm.\n    \"\"\"\n\n    def __init__(self, id: int, cnxn: sqlite3.Connection, **kwargs):\n        \"\"\"Constructor for the arm.\n\n        Args:\n            id (int): arm_id\n            cnxn (sqlite3.Connection): sqlite3.connection\n\n        Raises:\n            ValueError: provide `type` and `reward` to create entry in DimArm if none exists\n            ValueError: provide `customer_id` to create entry in AggregateResult if none exists\n        \"\"\"        \n\n        super().__init__()\n\n        self.cnxn = cnxn\n        self.id = id\n\n        # region checking DimArm\n\n        em = f\"No arm in db with id {id}\"\n\n        cur = list(self.exec(\"select type, reward, active from DimArm where arm_id = ?\", (id, )))\n\n        if len(cur) == 0:\n            if all([k in list(kwargs.keys()) for k in [\"type\", \"reward\"]]):\n                logging.warning(em + \", attempting to create one\")\n\n                sh = SqlHandler(\"DimArm\")\n                sh.insert_one(arm_id = id, type = kwargs[\"type\"], reward = kwargs[\"reward\"], active = 1)\n                self.type_, self.reward, self.active = kwargs[\"type\"], kwargs[\"reward\"], 1\n            else:\n                logging.error(em)\n                raise ValueError(em + \"provide `type` and `reward` to create one\")\n        else:\n            logging.info(\"Found arm in DimArm\")\n            self.type_, self.reward, self.active = cur[0]\n\n        # endregion checking DimArm\n\n        # region checking AggregateResult\n\n        self.sh = SqlHandler(\"AggregateResult\")\n\n        cur = list(self.exec(\"select customer_id, n_triggered, n_served, a, b, average_reward from AggregateResult where arm_id = ?\", (id,)))\n        if len(cur) == 0:\n            if \"customer_id\" in list(kwargs.keys()):\n                logging.warning(em + \", attempting to create one\")\n\n                self.sh.insert_one(arm_id = id, n_triggered = 0, n_served = 0, a = 1, b = 1, average_reward = 0, customer_id = kwargs[\"customer_id\"])\n                self.n_triggered, self.n_served, self.a, self.b, self.average_reward, self.customer_id = 0, 0, 1, 1, 0, kwargs[\"customer_id\"]\n            else:\n                logging.error(em)\n                raise ValueError(em + \"provide `customer_id` to create one\")\n        else:\n            logging.info(\"Found arm in AggregateResult\")\n            self.customer_id, self.n_triggered, self.n_served, self.a, self.b, self.average_reward = cur[0]\n\n        # endregion checking AggregateResult\n\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        String representation of the arm.\n        \"\"\"\n        return f\"Bandit {self.id} with {self.n_triggered / self.n_served} Win Rate\"\n\n\n    def pull(self) -&gt; float:\n        \"\"\"\n        Pulls a random number from the beta distribution (used to determine winner while allowing for exploration)\n        \"\"\"\n        sample = np.random.beta(self.a, self.b) if self.active else 0\n        return sample\n\n\n    def log_sampled(self, information: str = None) -&gt; dict:\n        \"\"\"Acknowledge the fact that this arm has been chosen by the algorithm\n\n        Args:\n            information (str, optional): Information provided by the customer to store without structure. Defaults to None.\n\n        Returns:\n            dict: serve\n        \"\"\"\n        self.n_served += 1\n        self.b = self.n_served - self.n_triggered + 1\n        self.sh.update_one(self.id, n_served = self.n_served, b = self.b)\n\n\n        dim_date = SqlHandler(\"DimDate\")\n        date_id = dim_date.get_next_id()\n        curr_date = datetime.now()\n        dim_date.insert_one(\n            date_id=date_id, \n            date=curr_date.strftime(\"%Y/%m/%d %H:%M:%S\"),\n            day=curr_date.day,\n            month=curr_date.month,\n            quarter=((curr_date.month-1) // 3) + 1,\n            year=curr_date.year\n        )\n\n\n        serve_tbl = SqlHandler(\"Serve\")\n        serve_id = serve_tbl.get_next_id()\n        serve_dict = dict(serve_id=serve_id, date_id=date_id, customer_id=self.customer_id, arm_id=self.id, information=information, result=None)\n        serve_tbl.insert_one(**serve_dict)\n\n        return serve_dict\n\n\n    def log_trigger(self, serve_id: int):\n        \"\"\"Acknowledge the fact that this arm triggered a reward\n\n        Args:\n            serve_id (int): serve_id\n        \"\"\"       \n\n        self.n_triggered += 1\n        self.average_reward = self.n_triggered * self.reward / self.n_served\n        self.a += 1\n        self.sh.update_one(self.id, n_triggered = self.n_triggered, average_reward = self.average_reward, a = self.a)\n\n        serve_tbl = SqlHandler(\"Serve\")\n        serve_tbl.update_one(serve_id, result=1)\n\n\n    def change_type(self, type = None):\n        \"\"\"Change the type of the arm\n\n        Args:\n            type (str, optional): Arm type. Defaults to None.\n        \"\"\"        \n        with SqlHandler(\"DimArm\") as dim_arm:\n            arm = dim_arm.select_one(self.id)\n            dim_arm.update_one(id, type=type)\n\n        self.type_ = type\n\n\n    def toggle_active(self):\n        with SqlHandler(\"DimArm\") as dim_arm:\n            dim_arm.update_one(self.id, active = not self.active)\n\n        self.active = not self.active\n        return self\n</code></pre> <p></p>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonAlgo.__init__","title":"<code>__init__(cnxn, customer_id)</code>","text":"<p>Constructor that initializes the thompson algorithm</p> <p>Parameters:</p> Name Type Description Default <code>cnxn</code> <code>Connection</code> <p>Connection to db</p> required <code>customer_id</code> <code>int</code> <p>customer_id</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>The customer has no active arms</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def __init__(self, cnxn: sqlite3.Connection, customer_id: int):\n    \"\"\"Constructor that initializes the thompson algorithm\n\n    Args:\n        cnxn (sqlite3.Connection): Connection to db\n        customer_id (int): customer_id\n\n    Raises:\n        ValueError: The customer has no active arms\n    \"\"\"        \n\n    self.cnxn = cnxn\n    self.customer_id = customer_id\n\n    arms = list(self.exec(\n        \"select arm_id, type, reward, active from DimArm where arm_id in (select arm_id from AggregateResult where customer_id = ?)\", \n        (customer_id,)\n    ))\n\n    if len([i for i in arms if i[-1]]) == 0:\n        logging.error((em := \"The customer has no active arms\"))\n        raise ValueError(em)\n\n    self.arms = [ThompsonArm(arm_id, cnxn, type=type_, reward=reward, active=active, customer_id=customer_id) for arm_id, type_, reward, active in arms]\n</code></pre>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonAlgo.get_best_arm","title":"<code>get_best_arm(information=None)</code>","text":"<p>Samples the best arm</p> <p>Parameters:</p> Name Type Description Default <code>information</code> <code>str</code> <p>Information provided by the customer to be stored without structure. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>serve</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def get_best_arm(self, information: str = None) -&gt; dict:\n    \"\"\"Samples the best arm\n\n    Args:\n        information (str, optional): Information provided by the customer to be stored without structure. Defaults to None.\n\n    Returns:\n        dict: serve \n    \"\"\"        \n    j = np.argmax([arm.pull() for arm in self.arms])\n    best_arm = self.arms[j]\n    serve = best_arm.log_sampled(information)\n\n    return serve\n</code></pre>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonArm.__init__","title":"<code>__init__(id, cnxn, **kwargs)</code>","text":"<p>Constructor for the arm.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>arm_id</p> required <code>cnxn</code> <code>Connection</code> <p>sqlite3.connection</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>provide <code>type</code> and <code>reward</code> to create entry in DimArm if none exists</p> <code>ValueError</code> <p>provide <code>customer_id</code> to create entry in AggregateResult if none exists</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def __init__(self, id: int, cnxn: sqlite3.Connection, **kwargs):\n    \"\"\"Constructor for the arm.\n\n    Args:\n        id (int): arm_id\n        cnxn (sqlite3.Connection): sqlite3.connection\n\n    Raises:\n        ValueError: provide `type` and `reward` to create entry in DimArm if none exists\n        ValueError: provide `customer_id` to create entry in AggregateResult if none exists\n    \"\"\"        \n\n    super().__init__()\n\n    self.cnxn = cnxn\n    self.id = id\n\n    # region checking DimArm\n\n    em = f\"No arm in db with id {id}\"\n\n    cur = list(self.exec(\"select type, reward, active from DimArm where arm_id = ?\", (id, )))\n\n    if len(cur) == 0:\n        if all([k in list(kwargs.keys()) for k in [\"type\", \"reward\"]]):\n            logging.warning(em + \", attempting to create one\")\n\n            sh = SqlHandler(\"DimArm\")\n            sh.insert_one(arm_id = id, type = kwargs[\"type\"], reward = kwargs[\"reward\"], active = 1)\n            self.type_, self.reward, self.active = kwargs[\"type\"], kwargs[\"reward\"], 1\n        else:\n            logging.error(em)\n            raise ValueError(em + \"provide `type` and `reward` to create one\")\n    else:\n        logging.info(\"Found arm in DimArm\")\n        self.type_, self.reward, self.active = cur[0]\n\n    # endregion checking DimArm\n\n    # region checking AggregateResult\n\n    self.sh = SqlHandler(\"AggregateResult\")\n\n    cur = list(self.exec(\"select customer_id, n_triggered, n_served, a, b, average_reward from AggregateResult where arm_id = ?\", (id,)))\n    if len(cur) == 0:\n        if \"customer_id\" in list(kwargs.keys()):\n            logging.warning(em + \", attempting to create one\")\n\n            self.sh.insert_one(arm_id = id, n_triggered = 0, n_served = 0, a = 1, b = 1, average_reward = 0, customer_id = kwargs[\"customer_id\"])\n            self.n_triggered, self.n_served, self.a, self.b, self.average_reward, self.customer_id = 0, 0, 1, 1, 0, kwargs[\"customer_id\"]\n        else:\n            logging.error(em)\n            raise ValueError(em + \"provide `customer_id` to create one\")\n    else:\n        logging.info(\"Found arm in AggregateResult\")\n        self.customer_id, self.n_triggered, self.n_served, self.a, self.b, self.average_reward = cur[0]\n</code></pre>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonArm.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the arm.</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    String representation of the arm.\n    \"\"\"\n    return f\"Bandit {self.id} with {self.n_triggered / self.n_served} Win Rate\"\n</code></pre>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonArm.change_type","title":"<code>change_type(type=None)</code>","text":"<p>Change the type of the arm</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Arm type. Defaults to None.</p> <code>None</code> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def change_type(self, type = None):\n    \"\"\"Change the type of the arm\n\n    Args:\n        type (str, optional): Arm type. Defaults to None.\n    \"\"\"        \n    with SqlHandler(\"DimArm\") as dim_arm:\n        arm = dim_arm.select_one(self.id)\n        dim_arm.update_one(id, type=type)\n\n    self.type_ = type\n</code></pre>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonArm.log_sampled","title":"<code>log_sampled(information=None)</code>","text":"<p>Acknowledge the fact that this arm has been chosen by the algorithm</p> <p>Parameters:</p> Name Type Description Default <code>information</code> <code>str</code> <p>Information provided by the customer to store without structure. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>serve</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def log_sampled(self, information: str = None) -&gt; dict:\n    \"\"\"Acknowledge the fact that this arm has been chosen by the algorithm\n\n    Args:\n        information (str, optional): Information provided by the customer to store without structure. Defaults to None.\n\n    Returns:\n        dict: serve\n    \"\"\"\n    self.n_served += 1\n    self.b = self.n_served - self.n_triggered + 1\n    self.sh.update_one(self.id, n_served = self.n_served, b = self.b)\n\n\n    dim_date = SqlHandler(\"DimDate\")\n    date_id = dim_date.get_next_id()\n    curr_date = datetime.now()\n    dim_date.insert_one(\n        date_id=date_id, \n        date=curr_date.strftime(\"%Y/%m/%d %H:%M:%S\"),\n        day=curr_date.day,\n        month=curr_date.month,\n        quarter=((curr_date.month-1) // 3) + 1,\n        year=curr_date.year\n    )\n\n\n    serve_tbl = SqlHandler(\"Serve\")\n    serve_id = serve_tbl.get_next_id()\n    serve_dict = dict(serve_id=serve_id, date_id=date_id, customer_id=self.customer_id, arm_id=self.id, information=information, result=None)\n    serve_tbl.insert_one(**serve_dict)\n\n    return serve_dict\n</code></pre>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonArm.log_trigger","title":"<code>log_trigger(serve_id)</code>","text":"<p>Acknowledge the fact that this arm triggered a reward</p> <p>Parameters:</p> Name Type Description Default <code>serve_id</code> <code>int</code> <p>serve_id</p> required Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def log_trigger(self, serve_id: int):\n    \"\"\"Acknowledge the fact that this arm triggered a reward\n\n    Args:\n        serve_id (int): serve_id\n    \"\"\"       \n\n    self.n_triggered += 1\n    self.average_reward = self.n_triggered * self.reward / self.n_served\n    self.a += 1\n    self.sh.update_one(self.id, n_triggered = self.n_triggered, average_reward = self.average_reward, a = self.a)\n\n    serve_tbl = SqlHandler(\"Serve\")\n    serve_tbl.update_one(serve_id, result=1)\n</code></pre>"},{"location":"models/#bayesian_ab_testing.models.TS_Bernoulli.ThompsonArm.pull","title":"<code>pull()</code>","text":"<p>Pulls a random number from the beta distribution (used to determine winner while allowing for exploration)</p> Source code in <code>bayesian_ab_testing\\models\\TS_Bernoulli\\bernoulli_algorithm.py</code> <pre><code>def pull(self) -&gt; float:\n    \"\"\"\n    Pulls a random number from the beta distribution (used to determine winner while allowing for exploration)\n    \"\"\"\n    sample = np.random.beta(self.a, self.b) if self.active else 0\n    return sample\n</code></pre>"},{"location":"other/","title":"Other","text":"Database etiquette interface/base class <code>ISQL_Etiquette</code> <p>Parent class for sql-facing classes</p> Source code in <code>bayesian_ab_testing\\utils.py</code> <pre><code>class ISQL_Etiquette:\n    \"\"\"Parent class for sql-facing classes\"\"\"\n    def __init__(self):\n        pass\n\n\n    def chk_conn(conn) -&gt; bool:\n        \"\"\"Check if connection is still alive\n\n        Args:\n            conn (sqlite3.connection): connection\n\n        Returns:\n            bool: True if is alive, false otherwise\n        \"\"\"        \n\n        try:\n            conn.cursor()\n            return True\n        except Exception as ex:\n            return False\n\n\n    def refresh_conn(self):\n        \"\"\"Make sure the connection is still alive\"\"\"\n        if not ISQL_Etiquette.chk_conn(self.cnxn):\n            self.cnxn = sqlite3.connect(db_path)\n\n\n    def exec(self, query: str, *args, **kwargs) -&gt; sqlite3.Cursor:\n        \"\"\"Executres a given query and commits immediately after\n\n        Args:\n            query (str): query string\n\n        Returns:\n            sqlite3.Cursor: cursor\n        \"\"\"       \n        self.refresh_conn()\n\n        cur = self.cnxn.execute(query, *args, **kwargs)\n        self.cnxn.commit() \n\n        return cur\n\n\n    def exec_many(self, query: str, *args, **kwargs) -&gt; sqlite3.Cursor:\n        \"\"\"Executres many queries and commits immediately after\n\n        Args:\n            query (str): query string\n\n        Returns:\n            sqlite3.Cursor: cursor\n        \"\"\"        \n\n        self.refresh_conn()\n\n        cur = self.cnxn.executemany(query, *args, **kwargs)\n        self.cnxn.commit()\n\n        return cur\n</code></pre> <p></p> Logger <code>CustomFormatter</code> <p>             Bases: <code>Formatter</code></p> <p>Custom formatter for Informative Logging</p> Source code in <code>bayesian_ab_testing\\logger\\logger.py</code> <pre><code>class CustomFormatter(logging.Formatter):\n\n    \"\"\" \n        Custom formatter for Informative Logging\n    \"\"\"\n    grey = \"\\x1b[38;20m\"\n    violet=\"\\x1b[38;5;183m\"\n    yellow = \"\\x1b[33;20m\"\n    red = \"\\x1b[31;20m\"\n    bold_red = \"\\x1b[31;1m\"\n    reset = \"\\x1b[0m\"\n    format = \"%(asctime)s - %(name)s - %(funcName)s - %(levelname)s - (%(message)s) - line: %(lineno)d\"\n    FORMATS = {\n        logging.DEBUG: grey + format + reset,\n        logging.INFO: violet + format + reset,\n        logging.WARNING: yellow + format + reset,\n        logging.ERROR: red + format + reset,\n        logging.CRITICAL: bold_red + format + reset\n    }\n    def format(self, record):\n        \"\"\"\n\n        Parameters\n        ----------\n        record : takes the record\n\n\n        Returns\n        -------\n        returns formated(colored) output\n        \"\"\"\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt)\n        return formatter.format(record)\n</code></pre>"},{"location":"other/#bayesian_ab_testing.utils.ISQL_Etiquette.chk_conn","title":"<code>chk_conn(conn)</code>","text":"<p>Check if connection is still alive</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>connection</code> <p>connection</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if is alive, false otherwise</p> Source code in <code>bayesian_ab_testing\\utils.py</code> <pre><code>def chk_conn(conn) -&gt; bool:\n    \"\"\"Check if connection is still alive\n\n    Args:\n        conn (sqlite3.connection): connection\n\n    Returns:\n        bool: True if is alive, false otherwise\n    \"\"\"        \n\n    try:\n        conn.cursor()\n        return True\n    except Exception as ex:\n        return False\n</code></pre>"},{"location":"other/#bayesian_ab_testing.utils.ISQL_Etiquette.exec","title":"<code>exec(query, *args, **kwargs)</code>","text":"<p>Executres a given query and commits immediately after</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>query string</p> required <p>Returns:</p> Type Description <code>Cursor</code> <p>sqlite3.Cursor: cursor</p> Source code in <code>bayesian_ab_testing\\utils.py</code> <pre><code>def exec(self, query: str, *args, **kwargs) -&gt; sqlite3.Cursor:\n    \"\"\"Executres a given query and commits immediately after\n\n    Args:\n        query (str): query string\n\n    Returns:\n        sqlite3.Cursor: cursor\n    \"\"\"       \n    self.refresh_conn()\n\n    cur = self.cnxn.execute(query, *args, **kwargs)\n    self.cnxn.commit() \n\n    return cur\n</code></pre>"},{"location":"other/#bayesian_ab_testing.utils.ISQL_Etiquette.exec_many","title":"<code>exec_many(query, *args, **kwargs)</code>","text":"<p>Executres many queries and commits immediately after</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>query string</p> required <p>Returns:</p> Type Description <code>Cursor</code> <p>sqlite3.Cursor: cursor</p> Source code in <code>bayesian_ab_testing\\utils.py</code> <pre><code>def exec_many(self, query: str, *args, **kwargs) -&gt; sqlite3.Cursor:\n    \"\"\"Executres many queries and commits immediately after\n\n    Args:\n        query (str): query string\n\n    Returns:\n        sqlite3.Cursor: cursor\n    \"\"\"        \n\n    self.refresh_conn()\n\n    cur = self.cnxn.executemany(query, *args, **kwargs)\n    self.cnxn.commit()\n\n    return cur\n</code></pre>"},{"location":"other/#bayesian_ab_testing.utils.ISQL_Etiquette.refresh_conn","title":"<code>refresh_conn()</code>","text":"<p>Make sure the connection is still alive</p> Source code in <code>bayesian_ab_testing\\utils.py</code> <pre><code>def refresh_conn(self):\n    \"\"\"Make sure the connection is still alive\"\"\"\n    if not ISQL_Etiquette.chk_conn(self.cnxn):\n        self.cnxn = sqlite3.connect(db_path)\n</code></pre>"},{"location":"other/#bayesian_ab_testing.logger.CustomFormatter.format","title":"<code>format(record)</code>","text":""},{"location":"other/#bayesian_ab_testing.logger.CustomFormatter.format--parameters","title":"Parameters","text":"<p>record : takes the record</p>"},{"location":"other/#bayesian_ab_testing.logger.CustomFormatter.format--returns","title":"Returns","text":"<p>returns formated(colored) output</p> Source code in <code>bayesian_ab_testing\\logger\\logger.py</code> <pre><code>def format(self, record):\n    \"\"\"\n\n    Parameters\n    ----------\n    record : takes the record\n\n\n    Returns\n    -------\n    returns formated(colored) output\n    \"\"\"\n    log_fmt = self.FORMATS.get(record.levelno)\n    formatter = logging.Formatter(log_fmt)\n    return formatter.format(record)\n</code></pre>"}]}